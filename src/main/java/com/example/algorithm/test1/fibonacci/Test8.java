package com.example.algorithm.test1.fibonacci;

public class Test8 {
    /**
     * 题目描述
     * 一只青蛙一次可以跳上1级台阶，也可以跳上2级。
     * 求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
     *
     * 动态规划的一种？
     * 分析：如何入手
     *
     * 本质上还是斐波那契数列，所以迭代也可以求
     * 原因：要求第n级台阶有多少可能，其实是由n-1 级台阶 可能性 + n-2级台阶的可能性 之和
     * 当成 dp 问题来想的话：首先分析问题，它最终解是由前面的解累积起来的解，如何缩小问题的规模？
     *
     * 首先可知，第一阶有只能一步，一种；，第二阶可以两次一步、一次两步两种
     *
     * 若楼梯阶级 n = 3
     * 跳 2 步到 3：剩下的是第一步没跳，起始跳到第一步只有一种
     * 跳 1 步到 3：剩下的是第二步没跳，起始跳到第二步有两种
     * 通过分类讨论，问题规模就减少了:
     *
     * 若楼梯阶级 n = n
     * 跳 2 步到 n：剩下的是第 n - 2 步没跳，起始跳到第 n - 2 步设它为 pre2 种
     * 跳 1 步到 n：剩下的是第 n - 1 步没跳，起始跳到第 n - 1 步设它为 pre1 种
     * 同时可以发现第 n 阶的解法，只要用到 n - 1 和 n - 2 阶是多少，其他的不用考虑，因此用两个变量临时存下来即可
     *
     * dp(i) = dp(i-2) + dp(i-1)
     *
     * （原因 是 只能每次跳1步 和 每次跳2步 所以才是 斐波那契数列）
     *  自己分析：
     *     1.重点先 规模问题，如何将n的规模拆分的思考非常重要 ，怎么将规模缩小
     *     2.碰到一个大规模问题，不要直接去从大规模全部实现的角度去出发，不容易处理，
     *     需要从程序角度出发，只思考一部分，思考局部的一部分，如一个任务拆分，每次只执行一部分，再递归给
     *     下一个任务去执行全部的角度想问题
     *     3.如何拆分问题大小？一般是想这个问题倒数第一步如何解决
     *
     *     重要的分析过程：
     *
     *     像上面n个台阶问题，每次跳1步或2步？
     *     1.假设：我们从最后一步出发
     *            为了实现跳上第n阶台阶，我们的最后一跳 目前只有2种选择 要么跳1步  要么跳 2步
     *
     *            如果最后一跳是跳1步跳到 第 n阶台阶，要实现这个要求，只能 从 第 n-1 阶台阶跳才可能
     *            如果最后一跳是跳2步调到 第 n阶台阶，要实现这个要求，只能 从 第 n-2 阶台阶跳才可能
     *
     *            所以问题变成 跳到 n台阶 降级到 从 第 n-1阶跳 或者 从 n-2阶台阶往上跳 为他们跳的可能性之和
     *
     *            设：第n-1 的跳法 为 x  第 n-2 阶台阶的跳法为 y
     *            则第n阶台阶的跳法  因为要到第n阶，最后一步只有2种可能性 要么从n-1跳 要么从 n-2跳
     *            从n-1 跳 只有一种 跳1步  所以跳法 = x*1
     *            从n-2 跳 只能一种 跳2步  所以跳法 = y*1
     *            而n 为最后一步可能性之和  n=  x+y
     *
     *            所以通项公式为 f(n)=f(n-1)+f(n-2)  变成 斐波那契数列
     *
     *
     *           一般这种规模问题，均从倒数第一步出发
     *
     *           这种问题，重要是找到通项公式
     *
     *           还有类似问题，一共有零钱 1,2,5,10 块  现在 有20元 如何 兑换零钱的换法？
     *
     *           先思考最后一步 最后 一次性凑成 可能性 分别 1,2,5,10  所以出发点分别为 19,18,15,10
     *           所以 f(20)=f(19)+f(15)+f(10)  则替换n f(n)=f(n-1)+f(n-2)+f(n-5)+f(n-10)
     *
     *
     *
     *
     *
     */

    public static void main(String[] args) {
        Test8 test = new Test8();
        System.out.println(test.jumpFloor(7));

    }

    public int jumpFloor(int target) {
        if(target<1){
            return 0;
        }
        if(target<3){
            return target;
        }
        /**
         * 列出所有可能结果，排除不能结果  这种不好实现
         */
        int pre=1; //1级 只有一种可能
        int current=2; //2级  有2种
        for(int i=3;i<=target;i++){
            current=current+pre;
            pre=current-pre;
        }
        return current;
    }
}
