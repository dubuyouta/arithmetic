package com.example.algorithm.test1;

import com.kecies.interview.algorithm.test1.array.*;
import com.kecies.interview.algorithm.test1.fibonacci.Test10;
import com.kecies.interview.algorithm.test1.fibonacci.Test7;
import com.kecies.interview.algorithm.test1.fibonacci.Test8;
import com.kecies.interview.algorithm.test1.fibonacci.Test9;
import com.kecies.interview.algorithm.test1.link.*;
import com.kecies.interview.algorithm.test1.matrix.Test1;
import com.kecies.interview.algorithm.test1.matrix.Test18;
import com.kecies.interview.algorithm.test1.matrix.Test67;
import com.kecies.interview.algorithm.test1.matrix.Test68;
import com.kecies.interview.algorithm.test1.number.*;
import com.kecies.interview.algorithm.test1.stack.Test19;
import com.kecies.interview.algorithm.test1.stack.Test20;
import com.kecies.interview.algorithm.test1.stack.Test5;
import com.kecies.interview.algorithm.test1.string.*;
import com.kecies.interview.algorithm.test1.tree.*;

public class ReadMe {
    /**
     * 算法相关测试  都在test1 相关目录下
     */

    /**
     * test1 目录下
     * 1.{@link Test1} 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
     * 请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数
     *
     * 2.{@link Test2}  请实现一个函数，将一个字符串中的每个空格替换成“%20”。
     * 例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
     *
     * 3.{@link Test3} 题目描述 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
     *
     * 4.{@link Test4} 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。
     * 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
     * 例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
     *
     * 5.{@link Test5} 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
     *
     * 6.{@link Test6}  把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，
     *         输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
     *         NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
     *
     * 7.{@link Test7} 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
     *          n<=39
     *
     * 8.{@link Test8} 一只青蛙一次可以跳上1级台阶，也可以跳上2级。
     *         求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。
     *
     * 9.{@link Test9} 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。
     *         求该青蛙跳上一个n级的台阶总共有多少种跳法。
     *
     * 10.{@link Test10} 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。
     *            请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
     *
     * 11.{@link Test11} 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示
     *
     * 12.{@link Test12} 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
     *            保证base和exponent不同时为0
     *
     * 13.{@link Test13}  输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，
     *            所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
     *
     * 14.{@link Test14} 输入一个链表，输出该链表中倒数第k个结点。
     *
     * 15.{@link Test15} 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则
     *
     * 16.{@link Test16} 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
     *
     * 17.{@link Test17} 操作给定的二叉树，将其变换为源二叉树的镜像。
     *
     * 18.{@link Test18} 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，
     *           如果输入如下4 X 4矩阵：
     *                                1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
     *            则依次打印出数字     1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.
     *
     *
     * 19.{@link Test19} 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））
     *
     * 20.{@link Test20}  输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。
     *           假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，
     *           序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
     *           （注意：这两个序列的长度是相等的）
     *
     * 21.{@link Test21} 从上往下打印出二叉树的每个节点，同层节点从左至右打印。
     *
     * 22.{@link Test22} 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
     *          如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
     *
     * 23.{@link Test23} 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
     *           路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
     *           (注意: 在返回值的list中，数组长度大的数组靠前)
     *
     * 24.{@link Test24} 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），
     *           返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
     *
     * 25.{@link Test25} 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。
     *            要求不能创建任何新的结点，只能调整树中结点指针的指向。
     *
     * 26.{@link Test26} 输入一个字符串,按字典序打印出该字符串中字符的所有排列。
     *            例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
     *
     * 27.{@link Test27} 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
     *             例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。
     *            由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0
     *
     * 28.{@link Test28} 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
     *
     * 29.{@link Test29} HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。
     *           今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,
     *            当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,
     *            并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},
     *            连续子向量的最大和为8(从第0个开始,到第3个为止)。
     *            给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
     *
     * 30.{@link Test30} 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
     *            为此他特别数了一下1~13中包含1的数字有1、10、11、12、13
     *             因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,
     *             可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
     *
     * 31.{@link Test31} 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
     *            例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323
     *
     * 32.{@link Test32} 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，
     *           但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
     *
     * 33.{@link Test33} 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置,
     *           如果没有则返回 -1（需要区分大小写）.
     *
     * 34.{@link Test34} 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,
     *           求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
     *
     * 35.{@link Test35} 给定任意一个自然数，获取它重新排列后，下一个比它大的自然数
     *
     * 36.{@link Test36} 输入两个链表，找出它们的第一个公共结点。
     *  （注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数
     *
     * 37.{@link Test37} 统计一个数字在排序数组中出现的次数
     *
     * 38.{@link Test38} 输入一棵二叉树，求该树的深度。
     *          从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
     *
     * 39.{@link Test39} 输入一棵二叉树，判断该二叉树是否是平衡二叉树。
     *    我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树
     *
     * 40.{@link Test40} 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
     *
     * 41.{@link Test41} 输出所有连接正整数和 100 的连续正整数 （连接正整数至少包含2个数）
     *           输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序
     *
     * 42.{@link Test42} 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，
     *           如果有多对数字的和等于S，输出两个数的乘积最小的。
     *
     *           对应每个测试案例，输出两个数，小的先输出
     *
     * 43. {@link Test43} 对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。
     *            例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”
     *
     * 44. {@link Test44} 字符串反转 如 student. a am I  变为 I am a student
     *
     * 45. {@link Test45} 扑克牌顺子 请从输入的一个数组中判断能否构成5个一连的顺子，输入的数范围为0-13的整数，
     *            其中0可以表示1~13的任意整数。若能构成顺子，返回true，否则返回false
     *
     * 46.{@link Test46}  一个从 0~n-1  的n个元素的环形链表，对于指定的数据m，从编号0的元素开始计数，计数到m-1;
     *            次元素移除链表，并且链表的下一个元素继续从0计数，直到剩下最后一个元素
     *
     * 47.{@link Test47} 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）
     *
     * 48.{@link Test48} 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
     *
     * 49.{@link Test49} 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。
     *           数值为0或者字符串不是一个合法的数值则返回0
     *
     * 50.{@link Test50} 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，
     *           但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。
     *           例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。
     *
     * 51.{@link Test51}  给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],
     *           其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。
     *           （注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）
     *
     * 52.{@link Test52} 请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，
     *           而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，
     *           匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，
     *           但是与"aa.a"和"ab*a"均不匹配
     *
     * 53.{@link Test53} 返回一个字符串最长连续子串
     *
     * 54.{@link Test54} 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
     *           例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。
     *           但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。
     *
     * 55.{@link Test55} 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，
     *            第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。
     *
     * 56.{@link Test56} 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
     *
     * 57.{@link Test57} 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，
     *           返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
     *
     * 58.{@link Test58} 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。
     *           注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
     *
     * 59.{@link Test59} 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
     *
     * 60.{@link Test60} 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，
     *           第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
     *
     * 61.{@link Test61} 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
     *
     * 62.{@link Test62} 实现序列化和反序列化二叉树
     *
     * 63.{@link Test63} 给定一棵二叉搜索树，
     *           请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。
     *
     * 64.{@link Test64} 使用多种方式遍历二叉树
     *
     * 65.{@link Test65} 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。
     *           如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()
     *           方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。
     *
     * 66.{@link Test66} 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
     *                   例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，
     *                  那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}；
     *                  针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：
     *                  {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}，
     *                  {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
     *
     * 67.{@link Test67} 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。
     *                   路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。
     *                   如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如
     *                   [a b c e]
     *                   [s f c s]
     *                   [a d e e]
     *                   矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，
     *                   因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。
     *
     * 68.{@link Test68} 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，
     *                   每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。
     *                   例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。
     *                   但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？
     *
     * 69.{@link Test69} 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1，m<=n），
     *                  每段绳子的长度记为k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？
     *                  例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
     *
     * 70.{@link Test70} 去除一个有序的数组中重复的数，得到数据使得每个数只出现一遍。
     *                   并且不借助其他的存储空间 空间复杂度 O（1）
     *
     * 71.{@link Test71} 判断一个字符串中是否包含子串，并返回原字符串中子串的起始位置
     *
     * 72.{@link Test73} 在一个乱序的数组中，找到一组数的和为10 的2个数的下标 （双向指针 towsum）
     *
     * 73.{@link Test74} 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，
     *                  垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x
     *                   轴共同构成的容器可以容纳最多的水。 双向指针法
     *
     *
     * 74.{@link Test75} 给定一个整数序列：a1, a2, ..., an，一个「132模式」的子序列 ai, aj, ak
     *                   被定义为：当 i < j < k 时，ai < ak < aj。
     *                  设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有「132模式」的子序列。
     *                  (2020-09-18 头条面试)
     *
     *
     */

}
